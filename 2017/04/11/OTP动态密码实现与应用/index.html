<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>OTP动态密码实现与场景应用 | LionCui的IT二三事</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OTP动态密码实现与场景应用</h1><a id="logo" href="/.">LionCui的IT二三事</a><p class="description">分享与记录</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">OTP动态密码实现与场景应用</h1><div class="post-meta">Apr 11, 2017</div><div class="post-content"><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>OTP动态密码常见是两种实现: <code>HOTP</code>(事件计数密码)与<code>TOTP</code>（基于时间密码）.</p>
<p>分别对应着RFC 协议 <a href="https://www.ietf.org/rfc/rfc4226.txt" target="_blank" rel="noopener">RFC4266</a> 和 <a href="https://www.ietf.org/rfc/rfc6238.txt" target="_blank" rel="noopener">RFC6238</a></p>
<p>而实际上<code>TOTP</code> 也是由<code>HOTP</code>演变过来, 利用UNIX时间戳来作为计数输入.</p>
<p> HOTP算法的实现关键是有：</p>
<ul>
<li>密钥K, 最小长度是 128 位, 推荐160 位长度</li>
<li>计数C, 8 字节的整数, 称为移动因子（moving factor）</li>
<li>HMAC哈希算法</li>
<li>密码长度, 一般默认6位</li>
</ul>
<blockquote>
<p>“计数” 是指生成密码时有客户端或者服务器提供的的事件变量</p>
</blockquote>
<p>OTP动态密码一般可以用作离线交易校验、动态密码二次验证、时间段动态密码等等.</p>
<p>本文将会用Python来简单实现算法逻辑后, 用例子来讲解如何利用OTP.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>算法本身可以用两条表达式来描述:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HOTP(K,C) = Truncate(HMAC-SHA-256(K,C))</span><br><span class="line">PWD(K,C,digit) = HOTP(K,C) mod 10Digit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过hmac计算摘要后截断,  将这个数对10的乘方（digit 指数范围 1-10）取模得到最终密码</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OTP</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, secret, digits=<span class="number">6</span>, hash=hashlib.sha256)</span>:</span></span><br><span class="line">        self.secret = secret.encode(<span class="string">"utf-8"</span>)</span><br><span class="line">        self.digits = digits</span><br><span class="line">        self.hash = hash</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        <span class="comment"># 生成8 bytes 整数作为计数器, 如果传入字符串则先计算md5</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(input, int):</span><br><span class="line">            c = (input).to_bytes(<span class="number">8</span>, byteorder=<span class="string">'big'</span>)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(input, str):</span><br><span class="line">            c = hashlib.md5(input.encode(<span class="string">"UTF-8"</span>)).digest()</span><br><span class="line">        <span class="keyword">elif</span> isinstance(input, bytes):</span><br><span class="line">            c = hashlib.md5(input).digest()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(TypeError)</span><br><span class="line">        <span class="comment"># 以一个密钥和一个消息为输入，生成一个消息摘要作为输出</span></span><br><span class="line">        hmac_digest = hmac.new(self.secret, c, self.hash).digest()</span><br><span class="line">        <span class="comment"># 得到摘要的bytes数组</span></span><br><span class="line">        hmac_hash = bytearray(hmac_digest)</span><br><span class="line">        <span class="comment"># 取数组最后一位的bytes的低位数作为偏移值</span></span><br><span class="line">        offset = hmac_hash[<span class="number">-1</span>] &amp; <span class="number">0xf</span></span><br><span class="line">        <span class="comment"># 从偏移量开始取4位bytes组合作为基础数</span></span><br><span class="line">        base_str = <span class="string">""</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> hmac_hash[offset:offset + <span class="number">4</span>]])</span><br><span class="line">        base_num = int(base_str, <span class="number">16</span>)</span><br><span class="line">        <span class="comment"># 取模得到密码</span></span><br><span class="line">        str_code = str(base_num % <span class="number">10</span> ** self.digits)</span><br><span class="line">        <span class="comment"># 根据长度返回密码, 不足则用0补全</span></span><br><span class="line">        <span class="keyword">if</span> len(str_code) &lt; self.digits:</span><br><span class="line">            str_code = <span class="string">'0'</span> * (self.digits -  len(str_code))+ str_code</span><br><span class="line">        <span class="keyword">return</span> str_code</span><br></pre></td></tr></table></figure>
<h2 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h2><blockquote>
<p>以下所有场景均保持终端与服务端使用相同算法、相同密钥的前提</p>
</blockquote>
<h3 id="离线交易验证"><a href="#离线交易验证" class="headerlink" title="离线交易验证"></a>离线交易验证</h3><p>在一些商业终端机设备(购物机、点唱机、自动按摩机、夹娃娃机等等)上进行交易动作, 通常这种类型的设备网络状态都不稳定, 用户扫码下单支付成功后, 支付服务器无法实时通知设备进行下一步.</p>
<p>这种场合可以在用户支付成功后根据订单信息来生成HTOP动态密码, 支付服务器返回密码给用户, 用户在设备验证该订单即可.</p>
<p>假设终端最新购物订单信息为: 苹果、价格200分、数量1个、下单时间 2017-04-11 12:33:45</p>
<p>生成密码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OTP</span><br><span class="line">otp = OTP(<span class="string">"HJZY243BSLI26PVW"</span>)</span><br><span class="line">order = &#123;</span><br><span class="line">    <span class="string">"product"</span>: <span class="string">"apple"</span>,</span><br><span class="line">  	<span class="string">"price"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"number"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="number">1491885225</span></span><br><span class="line">&#125;</span><br><span class="line">input_str = <span class="string">""</span>.join([order[k] <span class="keyword">for</span> k <span class="keyword">in</span> sorted(order.keys())])</span><br><span class="line">pwd = opt.generate(input_str)</span><br></pre></td></tr></table></figure>
<h3 id="动态密码验证"><a href="#动态密码验证" class="headerlink" title="动态密码验证"></a>动态密码验证</h3><p>常见的使用是手机动态口令，U盾动态口令, 在一些账号密码认证后进行的二次验证确认. 这个动态口令一般有生存时间(默认30秒)，在允许最长有效时间内均有效(注意: 这里用允许最长有效时间, 下面会说明)</p>
<p>首先明白OTP算法的外部变量就是”计数”</p>
<p>假设用户使用某账号<code>demo</code> 登录游戏, 这个使用游戏厂商的手机APP来生成动态口令, 触发时间为<code>2017-04-11 12:33:45</code> (转为UNIX TIMESTAMP 即为<code>1491885225</code>)</p>
<p>计数C的值 <code>1491885225 / 30 = 49729507</code></p>
<p>密码剩余有效时间为 <code>1491885225 % 30 = 15</code></p>
<p>口令APP根据剩余有效时间来刷新密码, 服务器则使用当前时间戳计算密码来验证用户输入的密码.</p>
<blockquote>
<p>注意: 这种验证了必须要求服务器与客户端的时间做NTP同步)</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OTP</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TOTP</span><span class="params">(OTP)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 密码最大允许有效时间</span></span><br><span class="line">        self.interval = kwargs.pop(<span class="string">'interval'</span>, <span class="number">30</span>)</span><br><span class="line">        self.period = <span class="number">0</span></span><br><span class="line">        super(TOTP, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timecode</span><span class="params">(self, unix_timestamp)</span>:</span></span><br><span class="line">        <span class="comment"># 生成时间计数</span></span><br><span class="line">        <span class="keyword">return</span> int(unix_timestamp / self.interval)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">period_life</span><span class="params">(self, unix_timestamp)</span>:</span></span><br><span class="line">        <span class="comment"># 密码剩余生存时间</span></span><br><span class="line">        <span class="keyword">return</span> self.interval - int(unix_timestamp % self.interval)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(self)</span>:</span></span><br><span class="line">        unix_timestamp = int(time.time())</span><br><span class="line">        self.period = self.period_life(unix_timestamp)</span><br><span class="line">        <span class="keyword">return</span> self.generate(self.timecode(unix_timestamp))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TOTP</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ACCOUNT = <span class="string">"demo"</span></span><br><span class="line">totp = TOTP(base64.b32encode(ACCOUNT.encode(<span class="string">"utf-8"</span>)).decode(<span class="string">"utf-8"</span>))</span><br><span class="line">print(<span class="string">"dynamic password: &#123;&#125;, time to live: &#123;&#125;s"</span>.format(totp.now(), totp.period))</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-nav"><a class="next" href="/2017/03/19/MQTT实时推送设计/">MQTT实时推送设计</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Openstack/" style="font-size: 15px;">Openstack</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MQTT/" style="font-size: 15px;">MQTT</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Ceph/" style="font-size: 15px;">Ceph</a> <a href="/tags/VMware/" style="font-size: 15px;">VMware</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/OTP动态密码实现与应用/">OTP动态密码实现与场景应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/MQTT实时推送设计/">MQTT实时推送设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/Golang为Python编写模块/">Golang为Python编写模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/Tkinter引入图标/">Tkinter如何引入图标</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/VPNaaS服务说明/">VPNaaS服务说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/LBaaS服务说明/">LBaaS服务说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/nova集成docker部署/">Nova集成Docker过程记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/23/自定义创建Openstack镜像(Windows)/">自定义制作Windows2008R2 nova镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/23/自定义制作centos6.6镜像/">自定义制作centos6.6 nova镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/07/openstack_i版本部署10/">Openstack I版部署安装(十)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">LionCui的IT二三事.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>